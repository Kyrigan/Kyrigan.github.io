import Html exposing (..)
import Html.Events exposing (onClick)
import StartApp.Simple as StartApp
import Text exposing (..)
import List 
import Basics exposing (..)
import Graphics.Collage exposing (..)
import Graphics.Element exposing (..)
import Color exposing (..)


--Hackathon API Code: Change things here!!

--use this to change the player graphics!
player = group [
                  circle 10 |> filled brown
               ]

--Add new lines to this list to add new potholes!
obsList = [
           (100,75)
          ,(90,-50)
          ,(110,10)
          ,(-100,-50)
          ,(-50,-40)
          ,(-90,30)
          ,(60,60)
          ]

--Change colour of potholes
potholeColour = red

--Change background colour of the play area
backgroundColour = darkBlue

initX = -150 --Change the starting x position of the player
initY = 0 -- Change the starting y-position of the player
areaWidth = 500 -- change the width of the play area 
areaHeight = 300 -- change the height of the play area

questionTxt = "(x+2/10)*5 = ?" --change the question 

--Change the background shapes /colors of the quiz options
answerBG= group[ rect 50 50           -- first option
                      |> filled white
                      |> move (200,-35)
                      , rect 50 50    --second option
                      |> filled white 
                      |> move (200,-100)
                      , rect 50 50    --third option
                      |> filled white 
                      |> move (200,100)
                      , rect 50 50    --fourth option
                      |> filled white
                      |> move (200,35)
               ]   
               
--Start time 


{-| Read more about StartApp and how this works at:

    https://github.com/evancz/start-app

The rough idea is that we just specify a model, a way to view it,
and a way to update it. That's all there is to it!
-}
main = StartApp.start { model = model, view = view, update = update }

model = { x = initX, y = initY , areaW = areaWidth, areaH = areaHeight, onTrap = False, 
          obstacleList = obsList,
          visibleList = List.repeat len False}
len = List.length obsList
view address model =   div [] [
                      table []
                [tr[] [
                      td [] [],
                      td [] [button [ onClick address Up ] [ Html.text "^" ]],
                      td [] []
                      ],
                 tr[] [
                      td [] [button [ onClick address Left ] [ Html.text "<" ]],
                      td [] [Html.text ("(" ++ toString model.x ++ "," ++ toString model.y ++ ")")],
                      td [] [ button [ onClick address Right ] [ Html.text ">" ]]
                      ],
                 tr[] [
                      td [] [],
                      td [] [button [ onClick address Down ] [ Html.text "v" ]],
                      td [] []
                      ]
                  ] ,
                      div [] [fromElement (shape model)]
                  
                      ]

shape model = collage (round (model.areaW)) (round (model.areaH)) 
                      [ rect (model.areaW) (model.areaH) |> filled black
                      , rect (model.areaW-10) (model.areaH-10) |> filled backgroundColour
                      , question |> move(-185,110)
                      , obstacleDrawer model.obstacleList model.visibleList
                      ,player
                      |> move (model.x,model.y) 
                      ,answerBG]

question = group [rect 102 52 |> filled black, rect 100 50 |> filled green, questionText]
questionText = group [Graphics.Collage.text (Text.bold(Text.fromString questionTxt))]

obstacleDrawer l lvis = group (List.map2 drawObstacle l lvis)
drawObstacle (x,y) vis = (obstacle vis) |> move (x, y)
obstacle vis = group [circle 10 |> filled (if vis then potholeColour else backgroundColour)]
obsradius = 700

--limit a b = --checker 100 75 85 110 50 100
--            if a >= 85 && a <= 110 && b >= 50 && b <= 100 then 85 
--            else if a >= 55 && a <= 80 && b >= -75 && b <= -25 then 55
--            else if a >= 105 && a <= 130 && b >= -15 && b <= 35 then 135
--            else if a >= -115 && a <= -90 && b >= -125 && b <= -75 then -115
--            else if a >= -65 && a <= -40 && b >= -45 && b <= 5 then -65
--           else if a >= -105 && a <= -80 && b >= 45 && b <= 95 then -105
--            else a 
--mapNextTo model (x,y) = if model.x >= ((fst (model.obstacleList)) - 15) && model.x >= ((fst (model.obstacleList)) + 10) && model.y >= ((snd (model.obstacleList)) - 25) && model.y >= ((snd (model.obstacleList)) + 25)
--                    then ((fst (model.obstacleList)) - 15)
--                else model.x
--mapNextTo model (x,y) = if model.x >= (x - 15) && model.x <= (x + 10) && model.y >= (y - 25) && model.y <= (y + 25)
--                    then (x-15) else model.x
--mapNextToList = List.map (mapNextTo model) model.obstacleList
--nextTo model = if model.x == List.map mapNextTo model.obstacleList then True else False

--funcname y= case y of:
            --tell you whether or not model.x is next to the object in the list obstacle list
            --(x::xs) -> funcname xs
            
--updateScore a b = if 
--checker a b xL xR yU yD = if a >= xL && a <= xR && b >= yD && b <= yU then xL 
                          --else a

--Check given coordinate of trap comparison to model character location
onCoordinate : { a | x : number', y : number } -> (number,number) -> Bool

onCoordinate model (x,y) = func model (x,y) <= obsradius                           

trapChecker model = List.map (onCoordinate model) model.obstacleList

visUpdate model = List.map2 (onCoordinateVis model) model.obstacleList model.visibleList
onCoordinateVis model (x,y) visible = if func model (x,y) <= obsradius && visible == False then True 
                                   else if visible then True 
                                   else False

func model (x,y)= ((x-model.x)^2+(y-model.y)^2)
--Return True or false
listChecker : { a | x : number', y : number, obstacleList: List(number,number) } -> Bool
listChecker model = List.foldr (||) (False) (trapChecker model) 
--If empty, no true (no trap contact), thus return false else true
checkTrap model = (listChecker model) 

resetX = -150
resetY = 0

type Action = Up | Down | Left | Right

update action model =
  case action of
    Up -> { model | onTrap = checkTrap model,
                    visibleList=visUpdate model,
                    y = if not model.onTrap then model.y + 6 else resetY,
                    x = if model.onTrap then resetX else model.x}
    Down -> { model | onTrap = checkTrap model,
                      visibleList=visUpdate model,
                     y = if not model.onTrap then model.y - 6 else resetY,
                     x = if model.onTrap then resetX else model.x}
    Left -> { model | onTrap = checkTrap model,
                      visibleList=visUpdate model,
                      x = if not model.onTrap then model.x - 6 else resetX,
                      y = if model.onTrap then resetY else model.y}
    Right -> { model | onTrap = checkTrap model,
                       visibleList=visUpdate model,
                       x = if not model.onTrap then model.x + 6 else resetX,
                       y = if model.onTrap then resetY else model.y}